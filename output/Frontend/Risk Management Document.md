# Risk Management Document (Frontend) — MySave

본 문서는 **MySave 프론트엔드(정적 HTML/CSS/JS + Chrome Extension)** 개발 과정에서 발생한 주요 이슈를 “문제 → 원인 → 대응/해결 → 배운 점” 흐름으로 정리한 리스크 관리 문서입니다.  
특히 OAuth 로그인 흐름, 데이터 저장소(localStorage ↔ DB) 전환, 대시보드 통계 렌더링 등 **서비스 신뢰도와 UX에 직접 영향을 주는 이슈**를 중심으로 기록했습니다.

---

## 1. 리스크 요약(한눈에 보기)

| ID | 리스크/문제 | 영향(Impact) | 현재 상태 | 대응 방향 |
|---:|---|---|---|---|
| R1 | 카카오 로그인 Redirect URI 불일치(500) | 로그인 불가(핵심 기능 차단) | 해결 | Redirect URI 로컬/배포 분리 관리 |
| R2 | 로그인 후 JSON 화면 노출(UX 멈춤) | 사용자 경험 붕괴, 이탈 가능 | 미해결(백엔드 수정 필요) | 백엔드 → 프론트 콜백 페이지로 redirect 설계 - 개선 권장 |
| R3 | localStorage ↔ DB 데이터 불일치(게스트→로그인) | 데이터 “사라짐”처럼 인지, 저장 주체 혼재 | 구조적 미해결 | 마이그레이션 API/정책 필요 - 개선 권장 |
| R4 | 대시보드 통계 카드 초기 문구 고정 | 신뢰도 저하(데이터가 있어도 계산 안 됨) | 해결 | 로드 타이밍/DOM 연결 정리, 날짜 로직 개선 |

---

## 2. 리스크 상세

## R1) 카카오 로그인 OAuth 2.0 Redirect URI 불일치 (500 Error)

- 문제  
  카카오 로그인 요청 후 인증이 끝나면 **500 에러**가 발생하거나, “Redirect URI 불일치” 오류로 로그인 흐름이 진행되지 않았습니다.

- 원인 분석  
  카카오 디벨로퍼스 콘솔에 등록된 Redirect URI와 실제 요청 Redirect URI가 달랐습니다.  
  예: 로컬 환경 `http://127.0.0.1:5500/...` vs 배포 환경 `https://...vercel.app/...` 혼용

- 대응/해결 과정  
  1) 프론트/백엔드에서 사용 중인 Redirect URI 후보를 전부 수집 및 정리  
  2) 카카오 디벨로퍼스 콘솔의 Redirect URI 목록에 로컬/배포 값을 각각 등록  
  3) 실제 로그인 요청이 호출하는 최종 URI를 확인하고, 프로젝트에서 “기준 Redirect URI”를 확정하여 문서화

- 결과  
  Redirect URI 불일치로 인한 로그인 실패(500) 문제를 해소했습니다.

- 배운 점  
  OAuth 2.0에서 Redirect URI는 “로그인 완료 후 사용자가 돌아오는 **정확한 주소**”이므로 **한 글자라도 다르면 인증 흐름이 즉시 깨집니다.**  
  로컬/배포 환경 분리를 전제로 Redirect URI를 운영해야 함을 학습했습니다.

---

## R2) 로그인 후 JSON 화면 멈춤 현상 (UX)

- 문제  
  카카오 로그인 인증은 성공했지만, 로그인 이후 서비스 화면으로 돌아오지 않고  
  백엔드 엔드포인트(`/api/auth/kakao/callback`)에 **JSON 문자열만 출력**되어 사용자가 “멈춘 것처럼” 인지했습니다.

- 원인 분석  
  인증 완료 후 사용자가 프론트엔드 `callback.html`로 돌아오는 구조가 아니라,  
  백엔드가 callback 처리 후 **JSON을 직접 응답**하여 브라우저에 그대로 노출되는 구조였습니다.  
  따라서 사용자 입장에서는 앱 화면 전환 없이 “JSON 응답 화면”에서 흐름이 종료된 것으로 느껴졌습니다.

- 대응/해결 과정(시도)  
  1) 현재 인증 플로우 정리: (카카오 → 백엔드 callback → JSON 응답)  
  2) 백엔드에 수정 요청사항 전달: 인증 완료 후 JSON 응답 대신 프론트 `callback.html`로 redirect 처리  
  3) 시간/일정 이슈로 백엔드 코드 수정 및 서버 재배포가 어려워 최종 반영하지 못했습니다.

- 현재 상태  
  **미해결(백엔드 수정 필요)**

- 배운 점  
  로그인 완료 이후 UX는 “JSON 응답 화면”이 아니라 “프론트 라우팅/화면 전환”으로 마무리되어야 합니다.  
  OAuth 인증 이후에는 **프론트가 토큰 저장 및 페이지 이동을 수행할 수 있도록 redirect 설계**가 필요했습니다. 

---

## R3) localStorage와 DB 간의 데이터 불일치 (게스트 → 로그인 전환)

- 문제  
  게스트 모드에서는 localStorage에 북마크/태그가 저장되는데, 로그인 이후 서버 DB 기반으로 전환될 때  
  기존 localStorage 데이터가 DB와 동기화되지 않아 데이터가 “사라진 것처럼” 보이거나 저장 주체가 혼재했습니다.

- 원인 분석  
  데이터 저장 방식이 “게스트(브라우저 localStorage)”와 “로그인(DB)”로 이원화되어 있었고,  
  로그인 시점에 localStorage 데이터를 userId 기반 DB로 마이그레이션하는 API/흐름이 준비되지 않았습니다.

- 대응/해결 과정(검토)  
  - 프론트 단에서 완전 해결이 어려워, UX 관점에서 “저장 위치가 달라지는 시점”을 사용자가 인지할 수 있도록 안내하는 방향을 검토했습니다.  
  - 그러나 백엔드 저장 API가 로그인(userId)을 전제로 구성되어 프론트에서 임의 동기화 구현이 어려웠습니다.

- 해결이 어려웠던 이유  
  게스트 상태에서 쌓인 데이터를 로그인 이후 자동 이관하기 위한 별도 엔드포인트(마이그레이션/병합 정책)가 필요합니다. - 개선 권장.

- 배운 점  
  localStorage 기반 MVP는 빠르게 기능을 만들 수 있지만, 로그인/동기화가 들어오는 순간 **데이터 소유권**과 **마이그레이션 정책(동기화/병합/초기화)**이 핵심 이슈가 됩니다.  
  초기 단계에서 게스트→로그인 전환 정책을 팀 단위로 합의해두는 것이 중요했습니다.

---

## R4) 대시보드 통계 카드가 초기 로드에서 “고정 문구”로 남는 문제

- 문제  
  대시보드 상단 통계 카드(오늘 저장한 글 / 미완료 리마인드 / 가장 자주 쓴 태그 / 주간 읽기 달성률)가  
  데이터가 있음에도 “데이터 계산 중…” 또는 임의 문구로 남아 신뢰도 낮은 화면이 보였습니다.

- 원인 분석  
  초기 HTML이 임시 문구로 구성되어 있었고, 실제 값 계산 로직이  
  (1) 로드 타이밍에 실행되지 않거나, (2) DOM 선택자가 정확히 연결되지 않은 상태였습니다.  
  또한 “오늘 날짜” 로직이 고정 데이터일 경우 “오늘 저장” 계산이 왜곡될 위험이 있었습니다.

- 대응/해결 과정  
  1) localStorage에서 bookmarks를 읽는 유틸 함수 정리(`getDashboardData`)  
  2) 페이지 로드 시 `updateDashboardStats()` 실행되도록 초기화 순서 정리(DOMContentLoaded 기반)  
  3) 날짜 계산을 고정값이 아닌 `new Date()` 기반으로 전환하여 “오늘 저장” 계산을 현재 기준으로 동작하도록 수정

- 결과  
  통계 카드가 초기 로드에서 실제 데이터로 정상 갱신되도록 개선했습니다.

- 배운 점  
  정적 멀티페이지 구조에서는 “초기 UI 문구”와 “JS로 갱신되는 영역”이 쉽게 분리되어,  
  **DOMContentLoaded 시점의 실행 순서**와 **DOM 연결 안정성**이 화면 품질(신뢰도)에 직접 영향을 준다는 것을 학습했습니다.

---

## 3. 기초웹개발론 수업에서 느낀 점(회고)

- 정적 멀티페이지 구조에서 대시보드/북마크/태그/리마인더 기능이 서로 연결되어 있어,  
  **한 기능의 수정이 다른 페이지의 연동 오류로 이어지는 경우**가 많았습니다.  
  특히 데이터 구조(localStorage 키/필드)나 공통 유틸 함수가 바뀌면 영향 범위가 커져 “수정 → 다른 기능 깨짐”을 반복적으로 경험했습니다.

- 이 문제를 줄이기 위해, “공통 데이터 구조/키/유틸 함수”를 먼저 정리하고  
  각 페이지가 그 규칙을 따르도록 점검하는 방식이 필요하다는 것을 배웠습니다.

- 기획 문서나 Figma에 없던 프론트엔드 구현 과정의 세부 결정(문구, 예외 처리, 상태 표시, 버튼 위치 등)은  
  팀원들과 Notion에 공유하고 회의를 통해 합의한 뒤 개발을 진행했습니다.  
  “사소한 결정”이 모여 실제 사용자 경험을 크게 좌우한다는 점을 체감했습니다.

- 처음 해보는 협업 경험을 통해, 기능 구현만큼이나  
  **문제 상황을 문서로 정리하고(현상/재현/원인 가설/요청 사항), 팀 간(프론트↔백) 소통을 구조화하는 능력**이 중요하다는 것을 배웠습니다.

---

## 4. 후속 개선 항목(정리)

- 카카오 로그인과 설정 페이지 기능들을 구현하고 싶습니다. 

