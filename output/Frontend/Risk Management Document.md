# Risk Management Document (Frontend) — MySave

본 문서는 **MySave 프론트엔드(정적 HTML/CSS/JS + Chrome Extension)** 개발 과정에서 발생한 주요 이슈를 “문제 → 원인 → 대응/해결 → 배운 점” 흐름으로 정리한 리스크 관리 문서입니다.  
특히 OAuth 로그인 흐름, 데이터 저장소(localStorage ↔ DB) 전환, 대시보드 통계 렌더링 등 **서비스 신뢰도와 UX에 직접 영향을 주는 이슈**를 중심으로 기록했습니다.

---

## 1. 리스크 요약(한눈에 보기)

| ID | 리스크/문제 | 영향(Impact) | 현재 상태 | 대응 방향 |
|---:|---|---|---|---|
| R1 | 카카오 로그인 Redirect URI 불일치(500) | 로그인 불가(핵심 기능 차단) | 해결 | Redirect URI 로컬/배포 분리 관리 |
| R2 | 로그인 후 JSON 화면 노출(UX 멈춤) | 사용자 경험 붕괴, 이탈 가능 | 미해결(백엔드 수정 필요) | 백엔드 → 프론트 콜백 페이지로 redirect 설계 |
| R3 | localStorage ↔ DB 데이터 불일치(게스트→로그인) | 데이터 “사라짐”처럼 인지, 저장 주체 혼재 | 구조적 미해결 | 마이그레이션 API/정책 필요|
| R4 | 대시보드 통계 카드 초기 문구 고정 | 신뢰도 저하(데이터가 있어도 계산 안 됨) | 해결 | 로드 타이밍/DOM 연결 정리, 날짜 로직 개선 |

---

## 2. 리스크 상세

### R1) 카카오 로그인 OAuth 2.0 Redirect URI 불일치 (500 Error)

- 문제  
  카카오 로그인 요청 후 인증이 끝나면 **500 에러**가 발생하거나, “Redirect URI 불일치” 오류로 로그인 흐름이 진행되지 않았습니다.

- 원인 분석  
  카카오 디벨로퍼스 콘솔에 등록된 Redirect URI와 실제 요청 Redirect URI가 달랐습니다.  

- 대응/해결 과정  
  1) 프론트/백엔드에서 사용 중인 Redirect URI 후보를 전부 수집 및 정리  
  2) 카카오 디벨로퍼스 콘솔의 Redirect URI 목록에 로컬/배포 값을 각각 등록  
  3) 실제 로그인 요청이 호출하는 최종 URI를 확인하고, 프로젝트에서 “기준 Redirect URI”를 확정하여 문서화

- 결과  
  Redirect URI 불일치로 인한 로그인 실패(500) 문제를 해결했습니다.

- 배운 점  
  OAuth 2.0에서 Redirect URI는 “로그인 완료 후 사용자가 돌아오는 **정확한 주소**”이므로 **한 글자라도 다르면 인증 흐름이 즉시 깨집니다.**  
이러한 경로를 인식하고 환경이 달라질 때마다 주소를 확인하는 것이 중요하다는 것을 느꼈습니다.
---

### R2) 로그인 후 JSON 화면 멈춤 현상 (UX)

- 문제  
  카카오 로그인 인증은 성공했지만, 로그인 이후 서비스 화면으로 돌아오지 않고  
  백엔드 엔드포인트(`/api/auth/kakao/callback`)에 **JSON 문자열만 출력**되어 사용자가 “멈춘 것처럼” 인지했습니다.

- 원인 분석  
  인증 완료 후 사용자가 프론트엔드 `callback.html`로 돌아오는 구조가 아니라,  
  백엔드가 callback 처리 후 **JSON을 직접 응답**하여 브라우저에 그대로 노출되는 구조였습니다.  
  따라서 사용자 입장에서는 앱 화면 전환 없이 “JSON 응답 화면”에서 흐름이 종료된 것으로 느껴졌습니다.

- 대응/해결 과정(시도)  
  1) 현재 인증 플로우 정리: (카카오 → 백엔드 callback → JSON 응답)  
  2) 백엔드에 수정 요청사항 전달: 인증 완료 후 JSON 응답 대신 프론트 `callback.html`로 redirect 처리  
  3) 시간/일정 이슈로 백엔드 코드 수정 및 서버 재배포가 어려워 최종 반영하지 못했습니다.

- 현재 상태  
  **미해결(백엔드 수정 필요)**

- 배운 점  
  로그인 완료 이후 UX는 “JSON 응답 화면”이 아니라 “프론트 라우팅/화면 전환”으로 마무리되어야 합니다.  
  OAuth 인증 이후에는 **프론트가 토큰 저장 및 페이지 이동을 수행할 수 있도록 redirect 설계**가 필요했습니다. 

---

### R3) localStorage와 DB 간의 데이터 불일치 (게스트 → 로그인 전환)

- 문제  
  게스트 모드에서는 localStorage에 북마크/태그가 저장되는데, 로그인 이후 서버 DB 기반으로 전환될 때  
  기존 localStorage 데이터가 DB와 동기화되지 않아 데이터가 사라진 것처럼 보이거나 저장 주체가 혼재했습니다.

- 원인 분석  
  데이터 저장 방식이 “게스트(브라우저 localStorage)”와 “로그인(DB)”로 이원화되어 있었고,  
  로그인 시점에 localStorage 데이터를 userId 기반 DB로 마이그레이션하는 API/흐름이 준비되지 않았습니다.

- 대응/해결 과정(검토)  
  - 프론트 선에서 완전 해결이 어려워, UX 관점에서 “저장 위치가 달라지는 시점”을 사용자가 인지할 수 있도록 안내하는 방향을 검토했습니다.  
  - 그러나 백엔드 저장 API가 로그인(userId)을 전제로 구성되어 프론트에서 임의 동기화 구현이 어려웠습니다.

- 해결이 어려웠던 이유  
  게스트 상태에서 쌓인 데이터를 로그인 이후 자동 이관하기 위한 별도 엔드포인트(마이그레이션/병합 정책)가 필요합니다.

- 배운 점  
  localStorage 기반에서는 빠르게 기능을 만들 수 있지만, 로그인/동기화가 들어오는 순간 **데이터 소유권**과 **마이그레이션 정책(동기화/병합/초기화)**이 핵심 이슈가 됩니다.  
  초기 단계에서 게스트→로그인 전환 정책을 팀 단위로 합의해두는 것이 중요했습니다.

---

### R4) 대시보드 통계 카드가 초기 로드에서 “고정 문구”로 남는 문제

- 문제  
  대시보드 상단 통계 카드(오늘 저장한 글 / 미완료 리마인드 / 가장 자주 쓴 태그 / 주간 읽기 달성률)가  
  데이터가 있음에도 “데이터 계산 중…” 또는 임의 문구로 남아 신뢰도 낮은 화면이 보였습니다.

- 원인 분석  
  초기 HTML이 임시 문구로 구성되어 있었고, 실제 값 계산 로직이  
  (1) 로드 타이밍에 실행되지 않거나, (2) DOM 선택자가 정확히 연결되지 않은 상태였습니다.  
  또한 “오늘 날짜” 로직이 고정 데이터일 경우 “오늘 저장” 계산이 왜곡될 위험이 있었습니다.

- 대응/해결 과정  
  1) localStorage에서 bookmarks를 읽는 유틸 함수 정리(`getDashboardData`)  
  2) 페이지 로드 시 `updateDashboardStats()` 실행되도록 초기화 순서 정리(DOMContentLoaded 기반)  
  3) 날짜 계산을 고정값이 아닌 `new Date()` 기반으로 전환하여 “오늘 저장” 계산을 현재 기준으로 동작하도록 수정

- 결과  
  통계 카드가 초기 로드에서 실제 데이터로 정상 갱신되도록 개선했습니다.

- 배운 점  
  정적 멀티페이지 구조에서는 “초기 UI 문구”와 “JS로 갱신되는 영역”이 쉽게 분리되어,  
  **DOMContentLoaded 시점의 실행 순서**와 **DOM 연결 안정성**이 직접 영향을 준다는 것을 확인했습니다.

---

## 3. 기초웹개발론 수업에서 느낀 점

- 정적 멀티페이지 구조에서 대시보드/북마크/태그/리마인더 기능이 서로 연결되어 있어,  
  **한 기능의 수정이 다른 페이지의 연동 오류로 이어지는 경우**가 많았습니다.  
  특히 데이터 구조(localStorage 키/필드)나 공통 유틸 함수가 바뀌면 영향 범위가 커져 “수정 → 다른 기능 깨짐”을 반복적으로 경험했습니다.

- 이 문제를 줄이기 위해, “공통 데이터 구조/키/유틸 함수”를 먼저 정리하고  
  각 페이지가 그 규칙을 따르도록 점검하는 방식이 필요하다는 것을 배웠습니다.

- 기획 문서나 Figma에 없던 프론트엔드 구현 과정의 세부 결정(문구, 예외 처리, 상태 표시, 버튼 위치 등)은  
  팀원들과 Notion에 공유하고 회의를 통해 합의한 뒤 개발을 진행했습니다.  
  사소한 결정이 모여 실제 사용자 경험을 크게 좌우한다는 점을 체감했습니다.

- 처음 해보는 협업 경험을 통해, 기능 구현만큼이나  
  **문제 상황을 문서로 정리하고(현상/재현/원인 가설/요청 사항), 팀 간(프론트↔백) 소통을 구조화하는 능력**이 중요하다는 것을 배웠습니다.

---

### 4. 후속 개선 항목

- 카카오 로그인과 설정 페이지 기능들을 구현하고 싶습니다.







## API 연동

프론트는 **정적 HTML/CSS/JS 기반**으로 먼저 MVP를 구현한 뒤, 백엔드 API가 준비되는 시점에 맞춰 **로그인/북마크 저장·조회 연동**을 단계적으로 붙였습니다.

이 과정에서 가장 큰 이슈는 다음 두 가지였습니다.

- **확장 프로그램 저장소 vs 웹 저장소 분리 문제**
- **인증/사용자 식별이 완성되지 않은 상태에서의 데이터 유지 문제**

---


### 1) 로그인 API 개발 전(서버 미완성) 대시보드 구현 시 발생한 문제

- 문제 상황  
  로그인(Auth)과 서버 DB가 완성되지 않은 상태에서, **확장 프로그램에서 저장한 데이터를 웹 대시보드에서 불러와야** 했습니다.

- 원인  
  브라우저 보안 정책상 **확장 프로그램 저장소(`chrome.storage`)** 와 **웹 페이지 저장소(`localStorage`)** 는 서로 격리되어 있어, 웹에서 확장 저장소를 직접 읽어오는 방식으로는 데이터 공유가 어렵습니다.

- 대응/해결 방향  
  - 웹 기능이 끊기지 않도록 `localStorage`를 **프론트의 기본 저장소**로 사용했습니다.
  - **게스트 모드 도입**: 토큰이 없는 경우에도 `userId: "guest"`를 기본값으로 두어 저장/조회 로직이 중단되지 않도록 처리했습니다.
  - **하이브리드 저장 전략**: 확장 프로그램 저장 시  
    1) 로컬 백업(브라우저 저장)  
    2) 서버 저장 요청(가능한 경우)  
    를 병행하도록 설계해 **데이터 유실 가능성**을 낮추는 방향으로 접근했습니다.

> 결과적으로 “백엔드가 없어도 웹이 돌아가고”, “백엔드가 준비되면 서버 연동으로 확장 가능”한 구조를 유지했습니다.

---


### 2) 로그인 API 연동

#### (1) 카카오 로그인 기본 플로우 구현

- 구현 방식  
  - `login.html`에서 백엔드의 로그인 URL 발급 API(`/api/auth/kakao/login-url`)를 호출해 사용자를 카카오 로그인 페이지로 이동
  - 인증 완료 후 카카오가 전달하는 `code`를 `callback.html`이 수신
  - `callback.html`이 해당 `code`를 백엔드 callback API로 전달하여 토큰 발급/검증을 수행하도록 구성
  - 백엔드에서 검증된 `accessToken`, `userId` 등을 전달받아 프론트에서 localStorage에 저장하도록 처리

#### (2) 로그인 연동 과정에서 발생했던 추가 문제

- 원인(정리)  
  정적 환경에서 화면 이동이 잦고, 토큰/유저 정보의 저장과 복구 흐름이 완전히 정리되지 않은 상태였습니다.  
  또한 서버 연동이 “로그인 사용자”를 전제로 설계되어 있어, 로그인 실패 시 대체 시나리오가 필요했습니다.

- 대응 방향  
  - 기획/백엔드와 논의 후 **게스트 모드 유지** 및 일부 테스트를 위한 **임시 userId 부여 방식**을 검토했습니다.
  - 다만 임시 userId 방식은  
    - 사용자 이름/이메일 처리(하드코딩/중복 등록 이슈)  
    - 이미 등록된 이메일로 인한 예외 상황  
    과 맞물려, 프론트 단독으로 완전한 안정화가 어려웠습니다.
  - 따라서 본 프로젝트에서는 **게스트(localStorage) 기반 기능을 우선 완성**하고, 로그인 기반 동기화는 **추가 개선 항목**으로 남겼습니다.

---


### 3) 북마크 API 연동

로그인 기반 서버 연동이 가능한 환경에서는, 프론트에서 생성한 북마크 데이터(URL/제목/메모/태그/리마인더 등)를 서버 DB와 연동하도록 구성했습니다.

- 북마크 목록 조회  
  - `GET /api/bookmarks?userId={id}`  
  - 서버 DB에 저장된 특정 사용자(`userId`)의 북마크 목록을 조회하여 화면에 렌더링합니다.

- 북마크 삭제  
  - `DELETE /api/bookmarks/{id}`  
  - 삭제 시 서버 DB에서도 동일하게 제거되도록 연동했습니다.

> 현재 구현에서는 localStorage 기반 동작을 우선 보장하고, 서버 API 연동은 로그인 안정화/동기화 정책 확정 이후 확장하는 방향으로 정리했습니다.
